"0","# Q1"
"0","5/6"
"1","[1]"
"1"," 0.8333333"
"1","
"
"0","# Q2"
"0","nrow(rolldie(3))"
"1","[1]"
"1"," 216"
"1","
"
"0","# Q3"
"0","Q3 = mutate(rolldie(4), total_5_6_7 = X1+X2+X3+X4)"
"0","total_outcomes = nrow(Q3)"
"0","Q3F = filter(Q3, total_5_6_7 %in% c(5,6,7))"
"0","filtered_outcomes = nrow(Q3F)"
"0","Q3_prob = filtered_outcomes/total_outcomes"
"0","# part 1"
"0","total_outcomes"
"1","[1]"
"1"," 1296"
"1","
"
"0","# part 2"
"0","Q3_prob"
"1","[1]"
"1"," 0.02623457"
"1","
"
"0","# part 3"
"0","# we assume that the the order of dice count as a different event even if the numbers are the same and functionaly identical"
"0","# Q4"
"0","2/nrow(permutations(5,5))"
"1","[1]"
"1"," 0.01666667"
"1","
"
"0","# the only possible correct states are ascending and descending."
"0","# however a programatic method could be deployed by running the sort() function and checking to see if the resulting vector matches the row."
"0","# due to time and patience, im going to just plug the 2 in"
